<!DOCTYPE html><html lang="en"><head><title>src/collision/sat</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../"><meta name="groc-document-path" content="src/collision/sat"><meta name="groc-project-path" content="work/game-builder/src/collision/sat.js"><link rel="stylesheet" type="text/css" media="all" href="../../assets/style.css"><script type="text/javascript" src="../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">work/game-builder/src/collision/sat.js</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="nx">define</span><span class="p">([</span><span class="s1">&#39;vector_2D&#39;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">Vector</span><span class="p">)</span> <span class="p">{</span>

  <span class="kd">var</span> <span class="nx">T_VECTORS</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">Vector</span><span class="p">());</span>
  <span class="p">}</span>
  
  <span class="kd">var</span> <span class="nx">T_ARRAYS</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">T_ARRAYS</span><span class="p">.</span><span class="nx">push</span><span class="p">([]);</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">Circle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">pos</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">pos</span> <span class="o">=</span> <span class="nx">pos</span> <span class="o">||</span> <span class="k">new</span> <span class="nx">Vector</span><span class="p">();</span>
    <span class="k">this</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">r</span> <span class="o">=</span> <span class="nx">r</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">Polygon</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">pos</span><span class="p">,</span> <span class="nx">points</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">pos</span> <span class="o">=</span> <span class="nx">pos</span> <span class="o">||</span> <span class="k">new</span> <span class="nx">Vector</span><span class="p">();</span>
    <span class="k">this</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">points</span> <span class="o">=</span> <span class="nx">points</span> <span class="o">||</span> <span class="p">[];</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">recalc</span><span class="p">();</span>
  <span class="p">};</span>

  <span class="nx">Polygon</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">recalc</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">points</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">points</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">edges</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">normals</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="nx">points</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="nx">points</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector</span><span class="p">().</span><span class="nx">copy</span><span class="p">(</span><span class="nx">p2</span><span class="p">).</span><span class="nx">sub</span><span class="p">(</span><span class="nx">p1</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector</span><span class="p">().</span><span class="nx">copy</span><span class="p">(</span><span class="nx">e</span><span class="p">).</span><span class="nx">perp</span><span class="p">().</span><span class="nx">normalize</span><span class="p">();</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">edges</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">normals</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">FixedSizePolygon</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">pos</span><span class="p">,</span> <span class="nx">points</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">pos</span> <span class="o">=</span> <span class="nx">pos</span> <span class="o">||</span> <span class="k">new</span> <span class="nx">Vector</span><span class="p">();</span>
    <span class="k">this</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">points</span> <span class="o">=</span> <span class="nx">points</span> <span class="o">||</span> <span class="p">[];</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">edges</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">normals</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">edges</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">Vector</span><span class="p">());</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">normals</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">Vector</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">recalc</span><span class="p">();</span>
  <span class="p">};</span>

  <span class="nx">FixedSizePolygon</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">recalc</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>    
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">edges</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">copy</span><span class="p">(</span><span class="nx">p</span><span class="p">).</span><span class="nx">sub</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">normals</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">copy</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">edges</span><span class="p">[</span><span class="nx">i</span><span class="p">]).</span><span class="nx">perp</span><span class="p">().</span><span class="nx">normalize</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">Response</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">[</span><span class="s1">&#39;overlapN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">overlapN</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector</span><span class="p">();</span> <span class="c1">// Unit vector in the direction of overlap</span>
    <span class="k">this</span><span class="p">[</span><span class="s1">&#39;overlapV&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">overlapV</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vector</span><span class="p">();</span> <span class="c1">// Subtract this from a&#39;s position to extract it from b</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>
  <span class="p">};</span>
  
  <span class="nx">Response</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clear</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">[</span><span class="s1">&#39;aInB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">aInB</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// Is a fully inside b?</span>
    <span class="k">this</span><span class="p">[</span><span class="s1">&#39;bInA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">bInA</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// Is b fully inside a?</span>
    <span class="k">this</span><span class="p">[</span><span class="s1">&#39;overlap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">overlap</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_VALUE</span><span class="p">;</span> <span class="c1">// Amount of overlap (magnitude of overlapV). Can be 0 (if a and b are touching)</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">flattenPointsOn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">points</span><span class="p">,</span> <span class="nx">normal</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">min</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_VALUE</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">max</span> <span class="o">=</span> <span class="o">-</span><span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_VALUE</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">points</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the magnitude of the projection of the point onto the normal</p></div></div><div class="code"><div class="wrapper">      <span class="kd">var</span> <span class="nx">dot</span> <span class="o">=</span> <span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">dot</span><span class="p">(</span><span class="nx">normal</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">dot</span> <span class="o">&lt;</span> <span class="nx">min</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">min</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">dot</span> <span class="o">&gt;</span> <span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">max</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">min</span><span class="p">;</span>
    <span class="nx">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">max</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">isSeparatingAxis</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">aPos</span><span class="p">,</span> <span class="nx">bPos</span><span class="p">,</span> <span class="nx">aPoints</span><span class="p">,</span> <span class="nx">bPoints</span><span class="p">,</span> <span class="nx">axis</span><span class="p">,</span> <span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">rangeA</span> <span class="o">=</span> <span class="nx">T_ARRAYS</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">rangeB</span> <span class="o">=</span> <span class="nx">T_ARRAYS</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the magnitude of the offset between the two polygons</p></div></div><div class="code"><div class="wrapper">    <span class="kd">var</span> <span class="nx">offsetV</span> <span class="o">=</span> <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">pop</span><span class="p">().</span><span class="nx">copy</span><span class="p">(</span><span class="nx">bPos</span><span class="p">).</span><span class="nx">sub</span><span class="p">(</span><span class="nx">aPos</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">projectedOffset</span> <span class="o">=</span> <span class="nx">offsetV</span><span class="p">.</span><span class="nx">dot</span><span class="p">(</span><span class="nx">axis</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Project the polygons onto the axis.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">flattenPointsOn</span><span class="p">(</span><span class="nx">aPoints</span><span class="p">,</span> <span class="nx">axis</span><span class="p">,</span> <span class="nx">rangeA</span><span class="p">);</span>
    <span class="nx">flattenPointsOn</span><span class="p">(</span><span class="nx">bPoints</span><span class="p">,</span> <span class="nx">axis</span><span class="p">,</span> <span class="nx">rangeB</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Move B's range to its position relative to A.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">rangeB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">projectedOffset</span><span class="p">;</span>
    <span class="nx">rangeB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">projectedOffset</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check if there is a gap. If there is, this is a separating axis and we can stop</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span> <span class="p">(</span><span class="nx">rangeA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">rangeB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">||</span> <span class="nx">rangeB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">rangeA</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">offsetV</span><span class="p">);</span>
      <span class="nx">T_ARRAYS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">rangeA</span><span class="p">);</span>
      <span class="nx">T_ARRAYS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">rangeB</span><span class="p">);</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we're calculating a response, calculate the overlap.</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">overlap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A starts further left than B</p></div></div><div class="code"><div class="wrapper">      <span class="k">if</span> <span class="p">(</span><span class="nx">rangeA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">rangeB</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">response</span><span class="p">.</span><span class="nx">aInB</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A ends before B does. We have to pull A out of B</p></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="p">(</span><span class="nx">rangeA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">rangeB</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
          <span class="nx">overlap</span> <span class="o">=</span> <span class="nx">rangeA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">rangeB</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
          <span class="nx">response</span><span class="p">.</span><span class="nx">bInA</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>B is fully inside A. Pick the shortest way out.</p></div></div><div class="code"><div class="wrapper">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">option1</span> <span class="o">=</span> <span class="nx">rangeA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">rangeB</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">option2</span> <span class="o">=</span> <span class="nx">rangeB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">rangeA</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
          <span class="nx">overlap</span> <span class="o">=</span> <span class="nx">option1</span> <span class="o">&lt;</span> <span class="nx">option2</span> <span class="o">?</span> <span class="nx">option1</span> <span class="o">:</span> <span class="o">-</span><span class="nx">option2</span><span class="p">;</span>
        <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>B starts further left than A</p></div></div><div class="code"><div class="wrapper">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">response</span><span class="p">.</span><span class="nx">bInA</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>B ends before A ends. We have to push A out of B</p></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="p">(</span><span class="nx">rangeA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">rangeB</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
          <span class="nx">overlap</span> <span class="o">=</span> <span class="nx">rangeA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">rangeB</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
          <span class="nx">response</span><span class="p">.</span><span class="nx">aInB</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A is fully inside B. Pick the shortest way out.</p></div></div><div class="code"><div class="wrapper">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">option1</span> <span class="o">=</span> <span class="nx">rangeA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">rangeB</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">option2</span> <span class="o">=</span> <span class="nx">rangeB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">rangeA</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
          <span class="nx">overlap</span> <span class="o">=</span> <span class="nx">option1</span> <span class="o">&lt;</span> <span class="nx">option2</span> <span class="o">?</span> <span class="nx">option1</span> <span class="o">:</span> <span class="o">-</span><span class="nx">option2</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.</p></div></div><div class="code"><div class="wrapper">      <span class="kd">var</span> <span class="nx">absOverlap</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">overlap</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">absOverlap</span> <span class="o">&lt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">overlap</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">response</span><span class="p">.</span><span class="nx">overlap</span> <span class="o">=</span> <span class="nx">absOverlap</span><span class="p">;</span>
        <span class="nx">response</span><span class="p">.</span><span class="nx">overlapN</span><span class="p">.</span><span class="nx">copy</span><span class="p">(</span><span class="nx">axis</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">overlap</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">response</span><span class="p">.</span><span class="nx">overlapN</span><span class="p">.</span><span class="nx">reverse</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">offsetV</span><span class="p">);</span>
    <span class="nx">T_ARRAYS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">rangeA</span><span class="p">);</span>
    <span class="nx">T_ARRAYS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">rangeB</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">LEFT_VORNOI_REGION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">MIDDLE_VORNOI_REGION</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">RIGHT_VORNOI_REGION</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">vornoiRegion</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="nx">point</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">len2</span> <span class="o">=</span> <span class="nx">line</span><span class="p">.</span><span class="nx">len2</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">dp</span> <span class="o">=</span> <span class="nx">point</span><span class="p">.</span><span class="nx">dot</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">dp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">LEFT_VORNOI_REGION</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">dp</span> <span class="o">&gt;</span> <span class="nx">len2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">RIGHT_VORNOI_REGION</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">MIDDLE_VORNOI_REGION</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">testCircleCircle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">differenceV</span> <span class="o">=</span> <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">pop</span><span class="p">().</span><span class="nx">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">pos</span><span class="p">).</span><span class="nx">sub</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">pos</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">totalRadius</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">r</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">r</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">totalRadiusSq</span> <span class="o">=</span> <span class="nx">totalRadius</span> <span class="o">*</span> <span class="nx">totalRadius</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">distanceSq</span> <span class="o">=</span> <span class="nx">differenceV</span><span class="p">.</span><span class="nx">len2</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">distanceSq</span> <span class="o">&gt;</span> <span class="nx">totalRadiusSq</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>They do not intersect</p></div></div><div class="code"><div class="wrapper">      <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">differenceV</span><span class="p">);</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>They intersect. If we're calculating a response, calculate the overlap.</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">dist</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="nx">distanceSq</span><span class="p">);</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">overlap</span> <span class="o">=</span> <span class="nx">totalRadius</span> <span class="o">-</span> <span class="nx">dist</span><span class="p">;</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">overlapN</span><span class="p">.</span><span class="nx">copy</span><span class="p">(</span><span class="nx">differenceV</span><span class="p">.</span><span class="nx">normalize</span><span class="p">());</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">overlapV</span><span class="p">.</span><span class="nx">copy</span><span class="p">(</span><span class="nx">differenceV</span><span class="p">).</span><span class="nx">scale</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">overlap</span><span class="p">);</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">aInB</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">r</span> <span class="o">&lt;=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">r</span> <span class="o">&amp;&amp;</span> <span class="nx">dist</span> <span class="o">&lt;=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">r</span> <span class="o">-</span> <span class="nx">a</span><span class="p">.</span><span class="nx">r</span><span class="p">;</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">bInA</span> <span class="o">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">r</span> <span class="o">&lt;=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">r</span> <span class="o">&amp;&amp;</span> <span class="nx">dist</span> <span class="o">&lt;=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">r</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">r</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">differenceV</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">testPolygonCircle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">polygon</span><span class="p">,</span> <span class="nx">circle</span><span class="p">,</span> <span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">circlePos</span> <span class="o">=</span> <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">pop</span><span class="p">().</span><span class="nx">copy</span><span class="p">(</span><span class="nx">circle</span><span class="p">.</span><span class="nx">pos</span><span class="p">).</span><span class="nx">sub</span><span class="p">(</span><span class="nx">polygon</span><span class="p">.</span><span class="nx">pos</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">radius</span> <span class="o">=</span> <span class="nx">circle</span><span class="p">.</span><span class="nx">r</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">radius2</span> <span class="o">=</span> <span class="nx">radius</span> <span class="o">*</span> <span class="nx">radius</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">points</span> <span class="o">=</span> <span class="nx">polygon</span><span class="p">.</span><span class="nx">points</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">points</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">edge</span> <span class="o">=</span> <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For each edge in the polygon</p></div></div><div class="code"><div class="wrapper">    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">next</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">===</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">prev</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">?</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">overlap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">overlapN</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the edge</p></div></div><div class="code"><div class="wrapper">      <span class="nx">edge</span><span class="p">.</span><span class="nx">copy</span><span class="p">(</span><span class="nx">polygon</span><span class="p">.</span><span class="nx">edges</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calculate the center of the cirble relative to the starting point of the edge</p></div></div><div class="code"><div class="wrapper">      <span class="nx">point</span><span class="p">.</span><span class="nx">copy</span><span class="p">(</span><span class="nx">circlePos</span><span class="p">).</span><span class="nx">sub</span><span class="p">(</span><span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the distance between the center of the circle and the point
is bigger than the radius, the polygon is definitely not fully in
the circle.</p></div></div><div class="code"><div class="wrapper">      <span class="k">if</span> <span class="p">(</span><span class="nx">response</span> <span class="o">&amp;&amp;</span> <span class="nx">point</span><span class="p">.</span><span class="nx">len2</span><span class="p">()</span> <span class="o">&gt;</span> <span class="nx">radius2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">response</span><span class="p">.</span><span class="nx">aInB</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calculate which Vornoi region the center of the circle is in.</p></div></div><div class="code"><div class="wrapper">      <span class="kd">var</span> <span class="nx">region</span> <span class="o">=</span> <span class="nx">vornoiRegion</span><span class="p">(</span><span class="nx">edge</span><span class="p">,</span> <span class="nx">point</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">region</span> <span class="o">===</span> <span class="nx">LEFT_VORNOI_REGION</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Need to make sure we're in the RIGHT<em>VORNOI</em>REGION of the previous edge.</p></div></div><div class="code"><div class="wrapper">        <span class="nx">edge</span><span class="p">.</span><span class="nx">copy</span><span class="p">(</span><span class="nx">polygon</span><span class="p">.</span><span class="nx">edges</span><span class="p">[</span><span class="nx">prev</span><span class="p">]);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calculate the center of the circle relative the starting point of the previous edge</p></div></div><div class="code"><div class="wrapper">        <span class="kd">var</span> <span class="nx">point2</span> <span class="o">=</span> <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">pop</span><span class="p">().</span><span class="nx">copy</span><span class="p">(</span><span class="nx">circlePos</span><span class="p">).</span><span class="nx">sub</span><span class="p">(</span><span class="nx">points</span><span class="p">[</span><span class="nx">prev</span><span class="p">]);</span>
        <span class="nx">region</span> <span class="o">=</span> <span class="nx">vornoiRegion</span><span class="p">(</span><span class="nx">edge</span><span class="p">,</span> <span class="nx">point2</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">region</span> <span class="o">===</span> <span class="nx">RIGHT_VORNOI_REGION</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>It's in the region we want. Check if the circle intersects the point.</p></div></div><div class="code"><div class="wrapper">          <span class="kd">var</span> <span class="nx">dist</span> <span class="o">=</span> <span class="nx">point</span><span class="p">.</span><span class="nx">len</span><span class="p">();</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">dist</span> <span class="o">&gt;</span> <span class="nx">radius</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No intersection</p></div></div><div class="code"><div class="wrapper">            <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">circlePos</span><span class="p">);</span>
            <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">edge</span><span class="p">);</span>
            <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">point</span><span class="p">);</span>
            <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">point2</span><span class="p">);</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
          <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>It intersects, calculate the overlap</p></div></div><div class="code"><div class="wrapper">            <span class="nx">response</span><span class="p">.</span><span class="nx">bInA</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
            <span class="nx">overlapN</span> <span class="o">=</span> <span class="nx">point</span><span class="p">.</span><span class="nx">normalize</span><span class="p">();</span>
            <span class="nx">overlap</span> <span class="o">=</span> <span class="nx">radius</span> <span class="o">-</span> <span class="nx">dist</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">point2</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">region</span> <span class="o">===</span> <span class="nx">RIGHT_VORNOI_REGION</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Need to make sure we're in the left region on the next edge</p></div></div><div class="code"><div class="wrapper">        <span class="nx">edge</span><span class="p">.</span><span class="nx">copy</span><span class="p">(</span><span class="nx">polygon</span><span class="p">.</span><span class="nx">edges</span><span class="p">[</span><span class="nx">next</span><span class="p">]);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calculate the center of the circle relative to the starting point of the next edge</p></div></div><div class="code"><div class="wrapper">        <span class="nx">point</span><span class="p">.</span><span class="nx">copy</span><span class="p">(</span><span class="nx">circlePos</span><span class="p">).</span><span class="nx">sub</span><span class="p">(</span><span class="nx">points</span><span class="p">[</span><span class="nx">next</span><span class="p">]);</span>
        <span class="nx">region</span> <span class="o">=</span> <span class="nx">vornoiRegion</span><span class="p">(</span><span class="nx">edge</span><span class="p">,</span> <span class="nx">point</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">region</span> <span class="o">===</span> <span class="nx">LEFT_VORNOI_REGION</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>It's in the region we want. Check if the circle intersects the point.</p></div></div><div class="code"><div class="wrapper">          <span class="kd">var</span> <span class="nx">dist</span> <span class="o">=</span> <span class="nx">point</span><span class="p">.</span><span class="nx">len</span><span class="p">();</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">dist</span> <span class="o">&gt;</span> <span class="nx">radius</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No intersection</p></div></div><div class="code"><div class="wrapper">            <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">circlePos</span><span class="p">);</span>
            <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">edge</span><span class="p">);</span>
            <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">point</span><span class="p">);</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
          <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>It intersects, calculate the overlap</p></div></div><div class="code"><div class="wrapper">            <span class="nx">response</span><span class="p">.</span><span class="nx">bInA</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
            <span class="nx">overlapN</span> <span class="o">=</span> <span class="nx">point</span><span class="p">.</span><span class="nx">normalize</span><span class="p">();</span>
            <span class="nx">overlap</span> <span class="o">=</span> <span class="nx">radius</span> <span class="o">-</span> <span class="nx">dist</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>MIDDLE<em>VORNOI</em>REGION</p></div></div><div class="code"><div class="wrapper">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Need to check if the circle is intersecting the edge,
Change the edge into its "edge normal".</p></div></div><div class="code"><div class="wrapper">        <span class="kd">var</span> <span class="nx">normal</span> <span class="o">=</span> <span class="nx">edge</span><span class="p">.</span><span class="nx">perp</span><span class="p">().</span><span class="nx">normalize</span><span class="p">();</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the perpendicular distance between the center of the
circle and the edge.</p></div></div><div class="code"><div class="wrapper">        <span class="kd">var</span> <span class="nx">dist</span> <span class="o">=</span> <span class="nx">point</span><span class="p">.</span><span class="nx">dot</span><span class="p">(</span><span class="nx">normal</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">distAbs</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">dist</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the circle is on the outside of the edge, there is no intersection</p></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="p">(</span><span class="nx">dist</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">distAbs</span> <span class="o">&gt;</span> <span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">circlePos</span><span class="p">);</span>
          <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">normal</span><span class="p">);</span>
          <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">point</span><span class="p">);</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>It intersects, calculate the overlap.</p></div></div><div class="code"><div class="wrapper">          <span class="nx">overlapN</span> <span class="o">=</span> <span class="nx">normal</span><span class="p">;</span>
          <span class="nx">overlap</span> <span class="o">=</span> <span class="nx">radius</span> <span class="o">-</span> <span class="nx">dist</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the center of the circle is on the outside of the edge, or part of the
circle is on the outside, the circle is not fully inside the polygon.</p></div></div><div class="code"><div class="wrapper">          <span class="k">if</span> <span class="p">(</span><span class="nx">dist</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">overlap</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">response</span><span class="p">.</span><span class="nx">bInA</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If this is the smallest overlap we've seen, keep it.
(overlapN may be null if the circle was in the wrong Vornoi region)</p></div></div><div class="code"><div class="wrapper">      <span class="k">if</span> <span class="p">(</span><span class="nx">overlapN</span> <span class="o">&amp;&amp;</span> <span class="nx">response</span> <span class="o">&amp;&amp;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">overlap</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">overlap</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">response</span><span class="p">.</span><span class="nx">overlap</span> <span class="o">=</span> <span class="nx">overlap</span><span class="p">;</span>
        <span class="nx">response</span><span class="p">.</span><span class="nx">overlapN</span><span class="p">.</span><span class="nx">copy</span><span class="p">(</span><span class="nx">overlapN</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calculate the final overlap vector - based on the smallest overlap.</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">polygon</span><span class="p">;</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">circle</span><span class="p">;</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">overlapV</span><span class="p">.</span><span class="nx">copy</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">overlapN</span><span class="p">).</span><span class="nx">scale</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">overlap</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">circlePos</span><span class="p">);</span>
    <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">edge</span><span class="p">);</span>
    <span class="nx">T_VECTORS</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">point</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">};</span>
  

  <span class="kd">var</span> <span class="nx">testCirclePolygon</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">circle</span><span class="p">,</span> <span class="nx">polygon</span><span class="p">,</span> <span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">testPolygonCircle</span><span class="p">(</span><span class="nx">polygon</span><span class="p">,</span> <span class="nx">circle</span><span class="p">,</span> <span class="nx">response</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="o">&amp;&amp;</span> <span class="nx">response</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Swap A and B in the response.</p></div></div><div class="code"><div class="wrapper">      <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">aInB</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">aInB</span><span class="p">;</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">overlapN</span><span class="p">.</span><span class="nx">reverse</span><span class="p">();</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">overlapV</span><span class="p">.</span><span class="nx">reverse</span><span class="p">();</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">aInB</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">bInA</span><span class="p">;</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">bInA</span> <span class="o">=</span> <span class="nx">aInB</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">testPolygonPolygon</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">aPoints</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">points</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">aLen</span> <span class="o">=</span> <span class="nx">aPoints</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">bPoints</span> <span class="o">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">points</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">bLen</span> <span class="o">=</span> <span class="nx">bPoints</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If any of the edge normals of A is a separating axis, no intersection.</p></div></div><div class="code"><div class="wrapper">    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">aLen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isSeparatingAxis</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">pos</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">pos</span><span class="p">,</span> <span class="nx">aPoints</span><span class="p">,</span> <span class="nx">bPoints</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">normals</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">response</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If any of the edge normals of B is a separating axis, no intersection.</p></div></div><div class="code"><div class="wrapper">    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">bLen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isSeparatingAxis</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">pos</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">pos</span><span class="p">,</span> <span class="nx">aPoints</span><span class="p">,</span> <span class="nx">bPoints</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">normals</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">response</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Since none of the edge normals of A or B are a separating axis, there is an intersection
and we've already calculated the smallest overlap (in isSeparatingAxis). Calculate the
final overlap vector.</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">overlapV</span><span class="p">.</span><span class="nx">copy</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">overlapN</span><span class="p">).</span><span class="nx">scale</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">overlap</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">SAT</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="nx">SAT</span><span class="p">[</span><span class="s1">&#39;Circle&#39;</span><span class="p">]</span>           <span class="o">=</span> <span class="nx">Circle</span><span class="p">;</span>
  <span class="nx">SAT</span><span class="p">[</span><span class="s1">&#39;Polygon&#39;</span><span class="p">]</span>          <span class="o">=</span> <span class="nx">Polygon</span><span class="p">;</span>
  <span class="nx">SAT</span><span class="p">[</span><span class="s1">&#39;FixedSizePolygon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">FixedSizePolygon</span><span class="p">;</span>
  <span class="nx">SAT</span><span class="p">[</span><span class="s1">&#39;Response&#39;</span><span class="p">]</span>         <span class="o">=</span> <span class="nx">Response</span><span class="p">;</span>

  <span class="nx">SAT</span><span class="p">[</span><span class="s1">&#39;testCircleCircle&#39;</span><span class="p">]</span>   <span class="o">=</span> <span class="nx">testCircleCircle</span><span class="p">;</span>
  <span class="nx">SAT</span><span class="p">[</span><span class="s1">&#39;testPolygonCircle&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="nx">testPolygonCircle</span><span class="p">;</span>
  <span class="nx">SAT</span><span class="p">[</span><span class="s1">&#39;testCirclePolygon&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="nx">testCirclePolygon</span><span class="p">;</span>
  <span class="nx">SAT</span><span class="p">[</span><span class="s1">&#39;testPolygonPolygon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">testPolygonPolygon</span><span class="p">;</span>

  <span class="k">return</span> <span class="nx">SAT</span><span class="p">;</span>
<span class="p">});</span></div></div></div></div></body></html>